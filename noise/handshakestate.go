package noise

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"io"
	"math"
	"math/big"

	"github.com/btcsuite/btcd/btcec"
	"github.com/lightningnetwork/lnd/keychain"
)

const (
	// HandshakeVersion0 is the expected version of the brontide handshake.
	// Any messages that carry a different version will cause the handshake
	// to abort immediately.
	HandshakeVersion0 = byte(0)

	HandshakeVersion1 = byte(1)

	// macSize is the length in bytes of the tags generated by poly1305.
	macSize = 16

	// lengthHeaderSize is the number of bytes used to prefix encode the
	// length of a message payload.
	lengthHeaderSize = 2

	// encHeaderSize is the number of bytes required to hold an encrypted
	// header and it's MAC.
	encHeaderSize = lengthHeaderSize + macSize
)

var (
	// N is the generator point we'll use for our PAKE protocol. It was
	// generated via a try-and-increment approach using the phrase
	// "Lightning Node Connect" with SHA2-256.
	nBytes, _ = hex.DecodeString(
		"0254a58cd0f31c008fd0bc9b2dd5ba586144933829f6da33ac4130b555fb5ea32c",
	)
	N, _ = btcec.ParsePubKey(nBytes, btcec.S256())
)

// handshakeState encapsulates the symmetricState and keeps track of all the
// public keys (static and ephemeral) for both sides during the handshake
// transcript. If the handshake completes successfully, then two instances of a
// cipherState are emitted: one to encrypt messages from initiator to
// responder, and the other for the opposite direction.
type handshakeState struct {
	symmetricState

	initiator bool

	s keychain.SingleKeyECDH
	e keychain.SingleKeyECDH // nolint (false positive)

	rs *btcec.PublicKey // nolint
	re *btcec.PublicKey // nolint

	password        []byte
	payloadToSend   []byte
	receivedPayload []byte

	pattern HandshakePattern

	version byte
}

func newHandshakeState(version byte, initiator bool, prologue []byte,
	localPub keychain.SingleKeyECDH, remoteStatic *btcec.PublicKey,
	password []byte, authData []byte) handshakeState {

	pattern := XXPattern()
	if remoteStatic != nil {
		pattern = KKPattern()
	}

	h := handshakeState{
		version:        version,
		symmetricState: symmetricState{},
		initiator:      initiator,
		s:              localPub,
		rs:             remoteStatic,
		pattern:        pattern,
		password:       password,
		payloadToSend:  authData,
	}

	protocolName := fmt.Sprintf(
		"Noise_%s_%s_%s_%s", pattern.Name, "secp256k1", "ChaChaPoly",
		"SHA256",
	)

	// Set the current chaining key and handshake digest to the hash of the
	// protocol name, and additionally mix in the prologue. If either sides
	// disagree about the prologue or protocol name, then the handshake
	// will fail.
	h.InitializeSymmetric([]byte(protocolName))
	h.mixHash(prologue)

	// TODO(roasbeef): if did mixHash here w/ the password, then the same
	// as using it as a PSK?

	// Call mixHash once for every pub key listed in the pre-messages from
	// the handshake pattern.
	for _, m := range pattern.PreMessages {
		if m.initiator == h.initiator {
			h.mixHash(localPub.PubKey().SerializeCompressed())
		} else {
			h.mixHash(remoteStatic.SerializeCompressed())
		}
	}

	return h
}

func (h *handshakeState) writeMsgPattern(mp MessagePattern, w io.Writer) error {
	buff := new(bytes.Buffer)

	// Write handshake byte to the buffer.
	if _, err := buff.Write([]byte{h.version}); err != nil {
		return err
	}

	// Write tokens.
	if err := h.writeTokens(mp.tokens, buff); err != nil {
		return err
	}

	// Write payload data.
	switch h.version {
	case HandshakeVersion0:
		var payload []byte
		switch mp.actNum {
		case 1, 3:
		case 2:
			// If we have an auth payload, then we'll write
			// out 2 bytes that denotes the true length of
			// the payload, followed by the payload itself.
			var payloadWriter bytes.Buffer
			payload = make([]byte, 500)

			if h.payloadToSend != nil {
				var length [2]byte
				payLoadLen := len(h.payloadToSend)
				binary.BigEndian.PutUint16(
					length[:], uint16(payLoadLen),
				)

				_, err := payloadWriter.Write(length[:])
				if err != nil {
					return err
				}

				_, err = payloadWriter.Write(h.payloadToSend)
				if err != nil {
					return err
				}
			}

			copy(payload[:], payloadWriter.Bytes())

		default:
			return fmt.Errorf("unknown act number: %d", mp.actNum)
		}

		_, err := buff.Write(h.EncryptAndHash(payload))
		if err != nil {
			return err
		}

	case HandshakeVersion1:
		var payload []byte
		switch mp.actNum {
		case 1, 3:
		case 2:
			payload = h.payloadToSend

			// The total length of each message payload including the MAC
			// size payload exceed the largest number encodable within a
			// 32-bit unsigned integer.
			if len(payload) > math.MaxUint32 {
				return ErrMaxMessageLengthExceeded
			}

			// The full length of the packet is only the packet length,
			// and does NOT include the MAC.
			fullLength := uint32(len(payload))

			var pktLen [4]byte
			binary.BigEndian.PutUint32(pktLen[:], fullLength)

			// First, generate the encrypted+MAC'd length prefix for the packet.
			_, err := buff.Write(h.EncryptAndHash(pktLen[:]))
			if err != nil {
				return err
			}

		default:
			return fmt.Errorf("unknown act number: %d", mp.actNum)
		}

		// Finally, generate the encrypted packet itself.
		_, err := buff.Write(h.EncryptAndHash(payload))
		if err != nil {
			return err
		}

	default:
		return fmt.Errorf("unknown handshake version: %v", h.version)
	}

	_, err := w.Write(buff.Bytes())
	return err
}

func (h *handshakeState) readMsgPattern(r io.Reader, mp MessagePattern) error {

	// Read and check version.
	version := [1]byte{}
	if _, err := r.Read(version[:]); err != nil {
		return err
	}

	if version[0] != h.version {
		return fmt.Errorf("received unexpected handshake version: %v",
			version[0])
	}

	// Read tokens.
	if err := h.readTokens(r, mp.tokens); err != nil {
		return err
	}

	// Read the payload data.
	switch h.version {
	case HandshakeVersion0:
		payloadSize := 0
		if mp.actNum == 2 {
			payloadSize = 500
		}

		cipherText := make([]byte, payloadSize+macSize)
		_, err := r.Read(cipherText[:])
		if err != nil {
			return err
		}

		payload, err := h.DecryptAndHash(cipherText[:])
		if err != nil {
			return err
		}

		// If the payload is a non-zero length, then we'll assume it's
		// the auth data and attempt to fully decode it.
		if len(payload) == 0 {
			return nil
		}

		payloadLen := binary.BigEndian.Uint16(payload[:2])
		authData := make([]byte, payloadLen)

		payloadReader := bytes.NewReader(payload[2:])
		if _, err := payloadReader.Read(authData); err != nil {
			return err
		}

		h.receivedPayload = authData

	case HandshakeVersion1:
		var payloadSize uint32
		switch mp.actNum {
		case 1, 3:
			payloadSize = macSize
		case 2:
			header := [4 + macSize]byte{}
			_, err := r.Read(header[:])
			if err != nil {
				return err
			}

			// Attempt to decrypt+auth the packet length present in
			// the stream.
			pktLenBytes, err := h.DecryptAndHash(header[:])
			if err != nil {
				return err
			}

			// Compute the packet length that we will need to read
			// off the wire.
			payloadSize = uint32(binary.BigEndian.Uint32(pktLenBytes)) + macSize

		default:
			return fmt.Errorf("unknown act number: %d", mp.actNum)
		}

		cipherText := make([]byte, payloadSize)
		_, err := r.Read(cipherText[:])
		if err != nil {
			return err
		}

		// Finally, decrypt the message held in the buffer, and return a
		// new byte slice containing the plaintext.
		authData, err := h.DecryptAndHash(cipherText[:])
		if err != nil {
			return err
		}

		if mp.actNum == 2 {
			h.receivedPayload = authData
		}

	default:
		return fmt.Errorf("unknown handshake version: %v", h.version)
	}

	return nil
}

func (h *handshakeState) writeTokens(tokens []Token, w io.Writer) error {
	for _, token := range tokens {
		switch token {
		case e:
			e, err := btcec.NewPrivateKey(btcec.S256())
			if err != nil {
				return err
			}

			h.e = &keychain.PrivKeyECDH{
				PrivKey: e,
			}

			pubKeyBytes := h.e.PubKey().SerializeCompressed()

			h.mixHash(pubKeyBytes)
			if _, err := w.Write(pubKeyBytes); err != nil {
				return err
			}

		case me:
			e, err := btcec.NewPrivateKey(btcec.S256())
			if err != nil {
				return err
			}

			h.e = &keychain.PrivKeyECDH{
				PrivKey: e,
			}

			pubKeyBytes := h.e.PubKey().SerializeCompressed()

			// Mix in the _unmasked_ ephemeral into the transcript
			// hash, as this allows us to use the MAC check to
			// assert if the remote party knows the password or not.
			h.mixHash(pubKeyBytes)

			// Now that we have our ephemeral, we'll apply the
			// eke-SPAKE2 specific portion by masking the key with
			// our password.
			me := ekeMask(h.e.PubKey(), h.password)
			_, err = w.Write(me.SerializeCompressed())
			if err != nil {
				return err
			}

		case s:
			pubKeyBytes := h.s.PubKey().SerializeCompressed()
			ct := h.EncryptAndHash(pubKeyBytes)

			if _, err := w.Write(ct); err != nil {
				return err
			}

		case ee:
			ee, err := ecdh(h.re, h.e)
			if err != nil {
				return err
			}
			h.mixKey(ee)

		case ss:
			ss, err := ecdh(h.rs, h.s)
			if err != nil {
				return err
			}
			h.mixKey(ss)

		case es:
			var (
				es  []byte
				err error
			)
			if h.initiator {
				es, err = ecdh(h.rs, h.e)
				if err != nil {
					return err
				}
			} else {
				es, err = ecdh(h.re, h.s)
				if err != nil {
					return err
				}
			}
			h.mixKey(es)

		case se:
			var (
				se  []byte
				err error
			)
			if h.initiator {
				se, err = ecdh(h.re, h.s)
				if err != nil {
					return err
				}
			} else {
				se, err = ecdh(h.rs, h.e)
				if err != nil {
					return err
				}
			}
			h.mixKey(se)

		default:
			return fmt.Errorf("unknown token: %s", token)
		}
	}

	return nil
}

func (h *handshakeState) readTokens(r io.Reader, tokens []Token) error {
	for _, token := range tokens {
		switch token {
		case e:
			e := [33]byte{}
			_, err := r.Read(e[:])
			if err != nil {
				return err
			}

			h.re, err = btcec.ParsePubKey(e[:], btcec.S256())
			if err != nil {
				return err
			}

			h.mixHash(h.re.SerializeCompressed())

		case me:
			var me [33]byte
			_, err := io.ReadFull(r, me[:])
			//_, err := r.Read(me[:])
			if err != nil {
				return err
			}

			maskedEphemeral, err := btcec.ParsePubKey(
				me[:], btcec.S256(),
			)
			if err != nil {
				return err
			}

			// Turn the masked ephemeral into a normal point, and
			// store that as the remote ephemeral key.
			h.re = ekeUnmask(maskedEphemeral, h.password)

			// We mix in this _unmasked_ point as otherwise we will
			// fail the MC check below if we didn't recover the
			// correct point.
			h.mixHash(h.re.SerializeCompressed())

		case s:
			s := [33 + 16]byte{}
			_, err := r.Read(s[:])
			if err != nil {
				return err
			}

			rs, err := h.DecryptAndHash(s[:])
			if err != nil {
				return err
			}

			h.rs, err = btcec.ParsePubKey(rs, btcec.S256())
			if err != nil {
				return err
			}

		case ee:
			ee, err := ecdh(h.re, h.e)
			if err != nil {
				return err
			}
			h.mixKey(ee)

		case ss:
			ss, err := ecdh(h.rs, h.s)
			if err != nil {
				return err
			}
			h.mixKey(ss)

		case es:
			var (
				es  []byte
				err error
			)
			if h.initiator {
				es, err = ecdh(h.rs, h.e)
				if err != nil {
					return err
				}
			} else {
				es, err = ecdh(h.re, h.s)
				if err != nil {
					return err
				}
			}
			h.mixKey(es)

		case se:
			var (
				se  []byte
				err error
			)
			if h.initiator {
				se, err = ecdh(h.re, h.s)
				if err != nil {
					return err
				}
			} else {
				se, err = ecdh(h.rs, h.e)
				if err != nil {
					return err
				}
			}
			h.mixKey(se)

		default:
			return fmt.Errorf("unknown token: %s", token)
		}
	}

	return nil
}

// ecdh performs an ECDH operation between pub and priv. The returned value is
// the sha256 of the compressed shared point.
func ecdh(pub *btcec.PublicKey, priv keychain.SingleKeyECDH) ([]byte, error) {
	hash, err := priv.ECDH(pub)
	return hash[:], err
}

// ekeMask masks the passed ephemeral key with the stored pass phrase, using
// SPAKE2 as the public masking operation: me = e + N*pw
func ekeMask(e *btcec.PublicKey, password []byte) *btcec.PublicKey {
	// me = e + N*pw
	passPointX, passPointY := btcec.S256().ScalarMult(N.X, N.Y, password)
	maskedEx, maskedEy := btcec.S256().Add(
		e.X, e.Y,
		passPointX, passPointY,
	)

	return &btcec.PublicKey{
		X:     maskedEx,
		Y:     maskedEy,
		Curve: btcec.S256(),
	}
}

// ekeUnmask does the inverse operation of ekeMask: e = me - N*pw
func ekeUnmask(me *btcec.PublicKey, password []byte) *btcec.PublicKey {
	// First, we'll need to re-generate the password point: N*pw
	passPointX, passPointY := btcec.S256().ScalarMult(N.X, N.Y, password)

	// With that generated, negate the y coordinate, then add that to the
	// masked point, which gives us the proper ephemeral key.
	passPointNegY := new(big.Int).Neg(passPointY)
	passPointNegY = passPointY.Mod(passPointNegY, btcec.S256().P)

	// e = me - N*pw
	eX, eY := btcec.S256().Add(
		me.X, me.Y,
		passPointX, passPointNegY,
	)

	return &btcec.PublicKey{
		X:     eX,
		Y:     eY,
		Curve: btcec.S256(),
	}
}
